import { CommonModule } from '@angular/common';
import {
  Component,
  ElementRef,
  EventEmitter,
  Input,
  Output,
  ViewChild,
} from '@angular/core';
import { FormsModule } from '@angular/forms';

import { Comment, MentionPattern } from '../../models/comment'; // Import the Comment interface
import { User } from '../../models/user';
import getCaretCoordinates from 'textarea-caret'; // Updated import statement

@Component({
  selector: 'comment-form',
  standalone: true,
  imports: [FormsModule, CommonModule],
  templateUrl: './comment-form.component.html',
  styleUrl: './comment-form.component.css',
})
export class CommentFormComponent {
  @Input() author: string = 'system';
  @Input() users: User[] = [];

  @Output() commentSubmitted = new EventEmitter<Comment>();
  @Output() notifyUser = new EventEmitter<string>();

  public showUserList: boolean = false;
  public filteredUsers: User[] = [];
  public userListStyle: { top: string; left: string } = {
    top: '0px',
    left: '0px',
  };
  public textArea: HTMLTextAreaElement | undefined = undefined;

  comment: Comment = {
    id: 5, // Hardcoded for now, but this would be generated by the server
    author: this.author,
    content: '',
    timestamp: new Date(),
  };

  onInput(event: Event): void {
    const input = (event.target as HTMLTextAreaElement).value;
    const char = input.charAt(input.length - 1);

    /** When user enters the @ character a popup will appear with a list of users, allowing them
     * to select a user to mention in the comment. */
    if (char === '@') {
      console.log('User is mentioning someone.');
      this.showUserList = true;
    }
  }

  onKeyUp(event: KeyboardEvent) {
    const input = (event.target as HTMLTextAreaElement).value;
    const mentionIndex = input.lastIndexOf('@');
    if (mentionIndex !== -1) {
      const mentionText = input.slice(mentionIndex + 1);

      /** Filter partial match by user name according to what user typed, then sort the list alphabetically. */
      this.filterAndSortUsers(mentionText);
      this.textArea = event.target as HTMLTextAreaElement;
      this.positionUserList(event.target as HTMLTextAreaElement);
    }
  }

  /** When a user is selected from the list, paste their name into the message. */
  onSelectUser(user: User) {
    const mentionIndex = this.comment.content.lastIndexOf('@');
    if (mentionIndex === -1) {
      console.error('No mention character found in comment.');
      return;
    }

    this.comment.content =
      this.comment.content.slice(0, mentionIndex + 1) + user.name + ' ';
    this.showUserList = false;
    this.focusTextarea();
  }

  onSubmit() {
    this.comment.timestamp = new Date();
    console.log('Comment submitted:', this.comment);
    this.findAllMentionsAndNotify();
    this.commentSubmitted.emit(this.comment); // Emit the new comment
    this.resetComment();
  }

  /** Check each mention and see if it is in the list of users.
   * If so, call function passed to us for this purpose. */
  private findAllMentionsAndNotify() {
    const matches = this.comment.content.match(MentionPattern);
    if (matches) {
      matches.forEach((match) => {
        const mention = match.slice(1); // Remove the @ character
        console.log('Mention detected:', mention);
        if (this.users.some((user) => user.name === mention)) {
          this.notifyUser.emit(mention);
        }
      });
    }
  }

  private resetComment() {
    this.comment = {
      id: 5, // Reset to a new id or handle id generation appropriately
      author: this.author,
      content: '',
      timestamp: new Date(),
    };
  }

  private filterAndSortUsers(mentionText: string) {
    this.filteredUsers = this.users
      .filter((user) =>
        user.name.toLowerCase().startsWith(mentionText.toLowerCase())
      )
      .sort((a, b) => {
        var nameA = a.name.toUpperCase();
        var nameB = b.name.toUpperCase();
        return nameA < nameB ? -1 : nameA > nameB ? 1 : 0;
      });
  }

  /** Place user list so it is just above the edit field. */
  private positionUserList(element: HTMLTextAreaElement) {
    let { top, left } = element.getBoundingClientRect();

    let caret = getCaretCoordinates(element, element.selectionEnd);
    top += caret.top;
    left += caret.left + 5;

    this.userListStyle = {
      top: `${top}px`,
      left: `${left}px`,
    };
  }

  private focusTextarea() {
    if (!this.textArea) {
      console.error('Textarea not found.');
      return;
    }

    const textarea = this.textArea;
    setTimeout(() => {
      textarea.focus();
      textarea.setSelectionRange(textarea.value.length, textarea.value.length);
    }, 0);
  }
}
